--- a/build-aux/ltmain.sh	2010-03-04 20:49:32.000000000 +0000
+++ b/build-aux/ltmain.sh	2010-03-02 23:04:58.000000000 +0000
@@ -3280,6 +3280,7 @@
 int lt_split_name_value (const char *arg, char** name, char** value);
 void lt_update_exe_path (const char *name, const char *value);
 void lt_update_lib_path (const char *name, const char *value);
+char **prepare_spawn (char **argv);
 
 static const char *script_text_part1 =
 EOF
@@ -3560,6 +3561,7 @@
 	      mingw*)
 		cat <<"EOF"
   /* execv doesn't actually work on mingw as expected on unix */
+  newargz = prepare_spawn (newargz);
   rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
   if (rval == -1)
     {
@@ -4023,8 +4025,125 @@
     }
 }
 
+EOF
+           case $host_os in
+	     mingw*)
+	       cat <<"EOF"
+
+/* Prepares an argument vector before calling spawn().
+   Note that spawn() does not by itself call the command interpreter
+     (getenv ("COMSPEC") != NULL ? getenv ("COMSPEC") :
+      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+         GetVersionEx(&v);
+         v.dwPlatformId == VER_PLATFORM_WIN32_NT;
+      }) ? "cmd.exe" : "command.com").
+   Instead it simply concatenates the arguments, separated by ' ', and calls
+   CreateProcess(). We must quote the arguments since Win32 CreateProcess()
+   interprets characters like ' ', '\t', '\\', '"' (but not '<' and '>') in a
+   special way:
+   - Space and tab are interpreted as delimiters. They are not treated as
+     delimiters if they are surrounded by double quotes: "...".
+   - Unescaped double quotes are removed from the input. Their only effect is
+     that within double quotes, space and tab are treated like normal
+     characters.
+   - Backslashes not followed by double quotes are not special.
+   - But 2*n+1 backslashes followed by a double quote become
+     n backslashes followed by a double quote (n >= 0):
+       \" -> "
+       \\\" -> \"
+       \\\\\" -> \\"
+ */
+#define SHELL_SPECIAL_CHARS "\"\\ \001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"
+#define SHELL_SPACE_CHARS " \001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"
+char **
+prepare_spawn (char **argv)
+{
+  size_t argc;
+  char **new_argv;
+  size_t i;
+
+  /* Count number of arguments. */
+  for (argc = 0; argv[argc] != NULL; argc++)
+    ;
+
+  /* Allocate new argument vector. */
+  new_argv = XMALLOC (char *, argc + 1);
+
+  /* Put quoted arguments into the new argument vector. */
+  for (i = 0; i < argc; i++)
+    {
+      const char *string = argv[i];
+
+      if (string[0] == '\0')
+        new_argv[i] = xstrdup ("\"\"");
+      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)
+        {
+          int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);
+          size_t length;
+          unsigned int backslashes;
+ 	  const char *s;
+ 	  char *quoted_string;
+          char *p;
+
+ 	  length = 0;
+ 	  backslashes = 0;
+ 	  if (quote_around)
+ 	    length++;
+ 	  for (s = string; *s != '\0'; s++)
+ 	    {
+ 	      char c = *s;
+ 	      if (c == '"')
+ 	        length += backslashes + 1;
+ 	      length++;
+ 	      if (c == '\\')
+ 	        backslashes++;
+              else
+                backslashes = 0;
+            }
+          if (quote_around)
+            length += backslashes + 1;
 
+          quoted_string = XMALLOC (char, length + 1);
+ 	  p = quoted_string;
+ 	  backslashes = 0;
+ 	  if (quote_around)
+ 	    *p++ = '"';
+ 	  for (s = string; *s != '\0'; s++)
+ 	    {
+ 	      char c = *s;
+ 	      if (c == '"')
+ 	        {
+ 	          unsigned int j;
+ 	          for (j = backslashes + 1; j > 0; j--)
+ 	            *p++ = '\\';
+ 	        }
+ 	      *p++ = c;
+ 	      if (c == '\\')
+ 	        backslashes++;
+ 	      else
+ 	        backslashes = 0;
+ 	    }
+ 	  if (quote_around)
+ 	    {
+ 	      unsigned int j;
+ 	      for (j = backslashes; j > 0; j--)
+ 	        *p++ = '\\';
+ 	      *p++ = '"';
+ 	    }
+ 	  *p = '\0';
+
+ 	  new_argv[i] = quoted_string;
+        }
+      else
+        new_argv[i] = (char *) string;
+    }
+  new_argv[argc] = NULL;
+
+  return new_argv;
+}
 EOF
+               ;;
+           esac
 }
 # end: func_emit_cwrapperexe_src
